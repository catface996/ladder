- **良好的逻辑设计和物理设计是高性能的基石**
- **应该根据要执行的查询语句来设计schema**
	- Question：面向领域 or 面向查询 来设计 schema ？
- 选择优化的数据类型
  collapsed:: true
	- 更小的通常更好
		- 占用磁盘少
		- 占用内存少
		- 占用CPU高速缓存少
		- 处理需要更少的CPU周期
	- 简单就好
		- 简单数据类型操作通常需要更少的CPU周期。例如，整形比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比整形比较更复杂。
	- 尽量避免NULL
		- 因为可NULL的列是的索引、索引统计和值比较都更复杂。
	- 整数类型
	  collapsed:: true
		- TINYINT 8位
		- SMALLINT 16位
		- MEDIUMINT 24位
		- INT 32位
		- BIGINT 64位
		- PS：对于存储和计算来说，INT(1) 和 INT(20) 是相同的。
	- 实数类型
	  collapsed:: true
		- FLOAT 4字节，32位
		- DOUBLE 8字节，64位
		- DECIMAL
		- CPU 不支持对DECIMAL的直接计算
		- 例如，DECIMAL（18,9）小数点两边将各存储9个数字，一共使用9个字节：小数点前的数字用4个字节，小数点后的数字用4个字节，小数点本身占1个字节
		- DECIMAL只是一种存储格式，在实际计算时，会转成double类型。
	- 字符串类型
	  collapsed:: true
		- VARCHAR 类型 和 CHAR 类型，存储格式跟存储引擎的类型有关，一般考虑InnoDB引擎下的格式。
		- VARCHAR
			- 需要使用1个或2个额外的字节记录字符串长度，列长度小于等于255使用1个字节，否则使用两个字节。
		- CHAR
			- 定长，例如存储密码的MD5值
			- 存储时，自动删除尾部的空格，是sever层的行为，非存储引擎的行为
	- BLOB 和 TEXT
	  collapsed:: true
		- 过大时，进行外部存储
	- 枚举
	  collapsed:: true
		- 略
	- 日期和时间类型
	  collapsed:: true
		- DATETIME 从1001年到9999年，精度为秒
		- TIMESTAMP
			- 与UNIX时间戳相同
			- 4字节，只能表示到2038年
			- 推荐使用，效率高
	- 主键
	  collapsed:: true
		- 优选整数类型
		- 避免使用字符串，很消耗空间，并且比数字慢
		- 随机字符串的缺点
			- 因为插入会随机地写到索引的不同位置，所以使得INSERT语句更慢。
			- select 语句会变的更慢，因为逻辑上相邻的行会分布在内存和磁盘的不同地方。
			- 随机值导致缓存对所有类型的查询语句效果都很差，因为会使得缓存赖以工作的访问局部性原理失效。
		- **当心自动生成的Schema**
			- 写的很烂的迁移程序
			- ORM框架生成的schema
	- 特殊类型数据
	  collapsed:: true
		- ip地址，事实上是32位无符号整数，使用INET_ATON 和 INET_NTOA
- MySQL schema设计中的陷阱
	- 太多的列
		- InnoDB需要将行缓冲中编码过的列转换成行数据结构，此过程消耗CPU
		- 导致一页（16K）中可存储的行数变少
	- 太多的关联
	- 全能的枚举
		- 注意防止过渡使用枚举
	- 变相的枚举
- 范式和反范式
	- 范式用来减少数据容易，保持数据一致性
	- 反范式通过数据冗余，提升查询效率
	- **完全的范式化和反范式化schema是实验室里才有的东西**
- 缓存表和汇总表
	- 物化视图
		- MySQL不支持，需要第三方工具
	- 计数器表
		- 单条记录更新时，互斥锁竞争频繁
		- 表中插入100行记录
		- 随机选一条，计数+1
		- 总计数为100条的累计计数
	- **更快地读，更慢地写**
- 加快ALTER TABLE操作的速度
	- 大部分ALTER TABLE会导致表重建，不是所有的ALTER TABLE都会引起表重建。
	- 只修改.frm文件，不涉及数据表的，会很快。
		- TODO 尝试交换.frm文件
- 总结
	- 尽量避免过渡设计
	- 使用小而简单的合适数据类型
	- 尽量使用相同的的数据类型存储相似或相关的值
	- 注意可变长字符串，
-